generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model action_editors {
  id                                     String      @id
  manuscriptId                           String      @unique
  editorId                               String
  assignedAt                             DateTime    @default(now())
  assignedBy                             String?
  users_action_editors_assignedByTousers users?      @relation("action_editors_assignedByTousers", fields: [assignedBy], references: [id])
  users_action_editors_editorIdTousers   users       @relation("action_editors_editorIdTousers", fields: [editorId], references: [id])
  manuscripts                            manuscripts @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
}

model bot_actions {
  id              String           @id
  botId           String
  name            String
  description     String
  inputSchema     Json
  createdAt       DateTime         @default(now())
  bot_definitions bot_definitions  @relation(fields: [botId], references: [id], onDelete: Cascade)
  bot_executions  bot_executions[]

  @@unique([botId, name])
}

model bot_config_files {
  id              String          @id
  botId           String
  filename        String
  storedName      String
  path            String
  mimetype        String
  size            Int
  checksum        String
  category        String
  description     String?
  metadata        Json?
  uploadedBy      String
  uploadedAt      DateTime        @default(now())
  updatedAt       DateTime
  bot_definitions bot_definitions @relation(fields: [botId], references: [id], onDelete: Cascade)
  users           users           @relation(fields: [uploadedBy], references: [id])

  @@unique([botId, filename])
}

model bot_definitions {
  id                  String             @id
  name                String
  description         String
  version             String
  author              String
  isPublic            Boolean            @default(false)
  configSchema        Json?
  createdAt           DateTime           @default(now())
  supportsFileUploads Boolean            @default(false)
  updatedAt           DateTime           @default(now())
  bot_actions         bot_actions[]
  bot_config_files    bot_config_files[]
  bot_executions      bot_executions[]
  bot_installs        bot_installs?
  bot_permissions     bot_permissions[]
}

model bot_executions {
  id              String             @id
  botId           String
  actionId        String?
  messageId       String?
  status          BotExecutionStatus @default(PENDING)
  input           Json?
  output          Json?
  error           String?
  executedAt      DateTime           @default(now())
  completedAt     DateTime?
  bot_actions     bot_actions?       @relation(fields: [actionId], references: [id])
  bot_definitions bot_definitions    @relation(fields: [botId], references: [id], onDelete: Cascade)
  messages        messages?          @relation(fields: [messageId], references: [id])
}

model bot_installs {
  id              String          @id
  botId           String          @unique
  config          Json            @default("{}")
  yamlConfig      String?         // YAML configuration with comments
  isEnabled       Boolean         @default(true)
  installedAt     DateTime        @default(now())
  updatedAt       DateTime        @default(now())
  bot_definitions bot_definitions @relation(fields: [botId], references: [id], onDelete: Cascade)
}

model bot_permissions {
  id              String          @id
  botId           String
  permission      String
  description     String
  bot_definitions bot_definitions @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@unique([botId, permission])
}

model conversation_participants {
  id             String          @id
  conversationId String
  userId         String
  role           ParticipantRole @default(PARTICIPANT)
  joinedAt       DateTime        @default(now())
  conversations  conversations   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  users          users           @relation(fields: [userId], references: [id])

  @@unique([conversationId, userId])
}

model conversations {
  id                        String                      @id
  title                     String
  type                      ConversationType
  privacy                   PrivacyLevel
  manuscriptId              String
  createdAt                 DateTime                    @default(now())
  updatedAt                 DateTime
  conversation_participants conversation_participants[]
  manuscripts               manuscripts                 @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  messages                  messages[]
}

model journal_settings {
  id          String   @id @default("singleton")
  name        String
  description String?
  logoUrl     String?
  settings    Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime
}

model magic_links {
  id          String    @id
  email       String
  token       String    @unique
  expiresAt   DateTime
  usedAt      DateTime?
  redirectUrl String?
  createdAt   DateTime  @default(now())
  userId      String?
  users       users?    @relation(fields: [userId], references: [id])
}

model manuscript_authors {
  id                  String      @id
  manuscriptId        String
  userId              String
  order               Int         @default(0)
  isCorresponding     Boolean     @default(false)
  creditRoles         String[]    @default([])
  affiliationOverride String?
  manuscripts         manuscripts @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  users               users       @relation(fields: [userId], references: [id])

  @@unique([manuscriptId, userId])
}

model manuscript_files {
  id             String             @id
  manuscriptId   String
  filename       String
  originalName   String
  mimetype       String
  size           Int
  path           String
  uploadedAt     DateTime           @default(now())
  checksum       String?
  detectedFormat String?
  encoding       String?
  fileExtension  String?
  fileType       ManuscriptFileType @default(SOURCE)
  storageType    StorageType        @default(LOCAL)
  manuscripts    manuscripts        @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
}

model manuscripts {
  id                   String               @id
  title                String
  abstract             String?
  content              String?
  status               ManuscriptStatus     @default(SUBMITTED)
  submittedAt          DateTime             @default(now())
  updatedAt            DateTime
  authors              String[]
  fileUrl              String?
  keywords             String[]             @default([])
  metadata             Json?
  publishedAt          DateTime?
  doi                  String?
  workflowPhase        WorkflowPhase        @default(REVIEW)
  workflowRound        Int                  @default(1)
  releasedAt           DateTime?
  // Publication metadata
  volume               String?
  issue                String?
  elocationId          String?              // For online-only articles
  articleType          String?              // research-article, review-article, etc.
  // Key dates for Crossref
  receivedDate         DateTime?            // Auto-set on submission
  acceptedDate         DateTime?            // Set when accepted
  // Crossref registration tracking
  crossrefDepositId    String?
  crossrefStatus       String?              // pending, success, failed
  crossrefError        String?
  crossrefRegisteredAt DateTime?
  // Subject classification for PMC/JATS
  subjects             String[]   @default([])
  action_editors       action_editors?
  conversations        conversations[]
  manuscript_authors   manuscript_authors[]
  manuscript_files     manuscript_files[]
  manuscript_funding   manuscript_funding[]
  review_assignments   review_assignments[]
  workflow_releases    workflow_releases[]
}

model messages {
  id             String           @id
  content        String
  conversationId String
  authorId       String
  parentId       String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime
  isBot          Boolean          @default(false)
  metadata       Json?
  privacy        MessagePrivacy   @default(AUTHOR_VISIBLE)
  deleted        Boolean          @default(false)
  deletedAt      DateTime?
  editedAt       DateTime?
  bot_executions bot_executions[]
  users          users            @relation(fields: [authorId], references: [id])
  conversations  conversations    @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  messages       messages?        @relation("messagesTomessages", fields: [parentId], references: [id])
  other_messages messages[]       @relation("messagesTomessages")
}

model review_assignments {
  id                 String               @id
  manuscriptId       String
  reviewerId         String
  status             ReviewStatus         @default(PENDING)
  assignedAt         DateTime             @default(now())
  dueDate            DateTime?
  completedAt        DateTime?
  responseToken      String?
  manuscripts        manuscripts          @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  users              users                @relation(fields: [reviewerId], references: [id])
  deadline_reminders deadline_reminders[]

  @@unique([manuscriptId, reviewerId])
}

model deadline_reminders {
  id                 String             @id @default(uuid())
  assignmentId       String
  daysBefore         Int
  scheduledFor       DateTime
  sentAt             DateTime?
  status             ReminderStatus     @default(PENDING)
  jobKey             String?            @unique
  errorMessage       String?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  review_assignments review_assignments @relation(fields: [assignmentId], references: [id], onDelete: Cascade)

  @@unique([assignmentId, daysBefore])
  @@index([assignmentId])
  @@index([status, scheduledFor])
}

model supported_formats {
  id             String   @id
  name           String   @unique
  displayName    String
  fileExtensions String[]
  mimeTypes      String[]
  description    String?
  rendererBotId  String?
  validatorBotId String?
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime
}

model users {
  id                                              String                      @id
  email                                           String                      @unique
  username                                        String                      @unique
  name                                            String?
  // Structured name for Crossref/JATS
  givenNames                                      String?
  surname                                         String?
  nameSuffix                                      String?
  orcidId                                         String?                     @unique
  orcidVerified                                   Boolean                     @default(false)
  createdAt                                       DateTime                    @default(now())
  updatedAt                                       DateTime
  affiliation                                     String?
  bio                                             String?
  website                                         String?
  role                                            GlobalRole                  @default(USER)
  action_editors_action_editors_assignedByTousers action_editors[]            @relation("action_editors_assignedByTousers")
  action_editors_action_editors_editorIdTousers   action_editors[]            @relation("action_editors_editorIdTousers")
  affiliations                                    affiliations[]
  bot_config_files                                bot_config_files[]
  conversation_participants                       conversation_participants[]
  magic_links                                     magic_links[]
  manuscript_authors                              manuscript_authors[]
  messages                                        messages[]
  review_assignments                              review_assignments[]
  workflow_releases                               workflow_releases[]
}

enum BotExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum ConversationType {
  EDITORIAL
  REVIEW
  SEMI_PUBLIC
  PUBLIC
  AUTHOR_ONLY
}

enum GlobalRole {
  ADMIN
  EDITOR_IN_CHIEF
  ACTION_EDITOR
  USER
  BOT
}

enum ManuscriptFileType {
  SOURCE
  ASSET
  RENDERED
  SUPPLEMENTARY
  BIBLIOGRAPHY
}

enum ManuscriptStatus {
  SUBMITTED
  UNDER_REVIEW
  REVISION_REQUESTED
  REVISED
  ACCEPTED
  REJECTED
  PUBLISHED
  RETRACTED
}

enum MessagePrivacy {
  PUBLIC
  AUTHOR_VISIBLE
  REVIEWER_ONLY
  EDITOR_ONLY
  ADMIN_ONLY
}

enum ParticipantRole {
  OBSERVER
  PARTICIPANT
  MODERATOR
}

enum PrivacyLevel {
  PRIVATE
  SEMI_PUBLIC
  PUBLIC
}

enum ReviewStatus {
  PENDING
  ACCEPTED
  DECLINED
  IN_PROGRESS
  COMPLETED
}

enum ReminderStatus {
  PENDING
  QUEUED
  SENT
  FAILED
  CANCELLED
}

enum StorageType {
  LOCAL
  S3
  GCS
  AZURE
}

enum WorkflowPhase {
  REVIEW
  DELIBERATION
  RELEASED
  AUTHOR_RESPONDING
}

model workflow_releases {
  id            String      @id @default(cuid())
  manuscriptId  String
  round         Int
  releasedAt    DateTime    @default(now())
  releasedBy    String
  decisionType  String?
  notes         String?
  manuscripts   manuscripts @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  users         users       @relation(fields: [releasedBy], references: [id])
}

model affiliations {
  id          String   @id @default(cuid())
  userId      String
  institution String
  department  String?
  city        String?
  state       String?
  country     String
  countryCode String?
  ror         String?
  isPrimary   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       users    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model manuscript_funding {
  id           String      @id @default(cuid())
  manuscriptId String
  funderName   String
  funderDoi    String?
  funderRor    String?
  awardId      String?
  awardTitle   String?
  createdAt    DateTime    @default(now())
  manuscripts  manuscripts @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)

  @@index([manuscriptId])
}
