generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String                    @id @default(cuid())
  email                    String                    @unique
  name                     String?
  orcidId                  String?                   @unique
  createdAt                DateTime                  @default(now())
  updatedAt                DateTime                  @updatedAt
  affiliation              String?
  bio                      String?
  website                  String?
  orcidVerified            Boolean                   @default(false)
  orcidAccessToken         String?
  role                     GlobalRole                @default(USER)
  assignedActionEditors    ActionEditor[]            @relation("ActionEditorAssigner")
  actionEditorRole         ActionEditor[]            @relation("ActionEditorRole")
  conversationParticipants ConversationParticipant[]
  magicLinks               MagicLink[]
  authoredManuscripts      ManuscriptAuthor[]
  authoredMessages         Message[]
  reviewAssignments        ReviewAssignment[]
  uploadedBotConfigFiles   BotConfigFile[]

  @@map("users")
}

model MagicLink {
  id          String    @id @default(cuid())
  email       String
  token       String    @unique
  expiresAt   DateTime
  usedAt      DateTime?
  redirectUrl String?
  createdAt   DateTime  @default(now())
  userId      String?
  user        User?     @relation(fields: [userId], references: [id])

  @@map("magic_links")
}

model JournalSettings {
  id          String   @id @default("singleton")
  name        String
  description String?
  logoUrl     String?
  settings    Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("journal_settings")
}

model Manuscript {
  id              String             @id @default(cuid())
  title           String
  abstract        String?
  content         String?
  status          ManuscriptStatus   @default(SUBMITTED)
  submittedAt     DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  authors         String[]
  fileUrl         String?
  keywords        String[]           @default([])
  metadata        Json?
  publishedAt     DateTime?
  doi             String?
  actionEditor    ActionEditor?
  conversations   Conversation[]
  authorRelations ManuscriptAuthor[] @relation("authorRelations")
  files           ManuscriptFile[]
  reviews         ReviewAssignment[]

  @@map("manuscripts")
}

model ManuscriptAuthor {
  id              String     @id @default(cuid())
  manuscriptId    String
  userId          String
  order           Int        @default(0)
  isCorresponding Boolean    @default(false)
  manuscript      Manuscript @relation("authorRelations", fields: [manuscriptId], references: [id], onDelete: Cascade)
  user            User       @relation(fields: [userId], references: [id])

  @@unique([manuscriptId, userId])
  @@map("manuscript_authors")
}

model ManuscriptFile {
  id           String     @id @default(cuid())
  manuscriptId String
  filename     String
  originalName String
  mimetype     String
  size         Int
  path         String
  uploadedAt   DateTime   @default(now())
  
  // Enhanced fields for submission system
  fileType     ManuscriptFileType @default(SOURCE)
  storageType  StorageType @default(LOCAL)
  checksum     String?    // For integrity verification
  encoding     String?    // Text encoding if applicable
  
  // Format detection
  detectedFormat String? // e.g., "markdown", "latex", "quarto"
  fileExtension  String? // Original file extension for format hints
  
  manuscript   Manuscript @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)

  @@map("manuscript_files")
}

model Conversation {
  id           String                    @id @default(cuid())
  title        String
  type         ConversationType
  privacy      PrivacyLevel
  manuscriptId String
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  participants ConversationParticipant[]
  manuscript   Manuscript                @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  messages     Message[]

  @@map("conversations")
}

model ConversationParticipant {
  id             String          @id @default(cuid())
  conversationId String
  userId         String
  role           ParticipantRole @default(PARTICIPANT)
  joinedAt       DateTime        @default(now())
  conversation   Conversation    @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User            @relation(fields: [userId], references: [id])

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model Message {
  id             String         @id @default(cuid())
  content        String
  conversationId String
  authorId       String
  parentId       String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  isBot          Boolean        @default(false)
  metadata       Json?
  privacy        MessagePrivacy @default(AUTHOR_VISIBLE)
  deleted        Boolean        @default(false)
  deletedAt      DateTime?
  editedAt       DateTime?
  botExecutions  BotExecution[]
  author         User           @relation(fields: [authorId], references: [id])
  conversation   Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  parent         Message?       @relation("MessageThread", fields: [parentId], references: [id])
  replies        Message[]      @relation("MessageThread")

  @@map("messages")
}

model ReviewAssignment {
  id           String       @id @default(cuid())
  manuscriptId String
  reviewerId   String
  status       ReviewStatus @default(PENDING)
  assignedAt   DateTime     @default(now())
  dueDate      DateTime?
  completedAt  DateTime?
  manuscript   Manuscript   @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  reviewer     User         @relation(fields: [reviewerId], references: [id])

  @@unique([manuscriptId, reviewerId])
  @@map("review_assignments")
}

model BotDefinition {
  id                   String          @id
  name                 String
  description          String
  version              String
  author               String
  isPublic             Boolean         @default(false)
  configSchema         Json?
  supportsFileUploads  Boolean         @default(false)
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @default(now()) @updatedAt
  actions              BotAction[]
  executions           BotExecution[]
  install              BotInstall?
  permissions          BotPermission[]
  configFiles          BotConfigFile[]

  @@map("bot_definitions")
}

model BotInstall {
  id          String        @id @default(cuid())
  botId       String        @unique
  config      Json          @default("{}")
  isEnabled   Boolean       @default(true)
  installedAt DateTime      @default(now())
  updatedAt   DateTime      @default(now()) @updatedAt
  bot         BotDefinition @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@map("bot_installs")
}

model BotPermission {
  id          String        @id @default(cuid())
  botId       String
  permission  String
  description String
  bot         BotDefinition @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@unique([botId, permission])
  @@map("bot_permissions")
}

model BotAction {
  id          String         @id @default(cuid())
  botId       String
  name        String
  description String
  inputSchema Json
  createdAt   DateTime       @default(now())
  bot         BotDefinition  @relation(fields: [botId], references: [id], onDelete: Cascade)
  executions  BotExecution[]

  @@unique([botId, name])
  @@map("bot_actions")
}

model BotExecution {
  id          String             @id @default(cuid())
  botId       String
  actionId    String?
  messageId   String?
  status      BotExecutionStatus @default(PENDING)
  input       Json?
  output      Json?
  error       String?
  executedAt  DateTime           @default(now())
  completedAt DateTime?
  action      BotAction?         @relation(fields: [actionId], references: [id])
  bot         BotDefinition      @relation(fields: [botId], references: [id], onDelete: Cascade)
  message     Message?           @relation(fields: [messageId], references: [id])

  @@map("bot_executions")
}

model BotConfigFile {
  id          String        @id @default(cuid())
  botId       String
  filename    String        // Original filename (e.g., "my-template.html")
  storedName  String        // Unique stored filename 
  path        String        // File path on storage
  mimetype    String        // MIME type of the file
  size        Int           // File size in bytes
  checksum    String        // SHA256 checksum for integrity
  category    String        // File category (kept for backwards compatibility)
  description String?       // Optional description
  metadata    Json?         // Additional metadata specific to the file type
  uploadedBy  String        // User who uploaded the file
  uploadedAt  DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  bot         BotDefinition @relation(fields: [botId], references: [id], onDelete: Cascade)
  uploader    User          @relation(fields: [uploadedBy], references: [id])

  @@unique([botId, filename]) // Prevent duplicate filenames per bot
  @@map("bot_config_files")
}

// Flexible format registry for supported formats
model SupportedFormat {
  id           String   @id @default(cuid())
  name         String   @unique // e.g., "markdown", "latex", "quarto"
  displayName  String   // e.g., "Markdown", "LaTeX", "Quarto"
  fileExtensions String[] // e.g., [".md", ".markdown"]
  mimeTypes    String[] // e.g., ["text/markdown"]
  description  String?  // Description of the format
  
  // Bot configuration
  rendererBotId String?
  validatorBotId String?
  
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("supported_formats")
}

model ActionEditor {
  id             String     @id @default(cuid())
  manuscriptId   String     @unique
  editorId       String
  assignedAt     DateTime   @default(now())
  assignedBy     String?
  assignedByUser User?      @relation("ActionEditorAssigner", fields: [assignedBy], references: [id])
  editor         User       @relation("ActionEditorRole", fields: [editorId], references: [id])
  manuscript     Manuscript @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)

  @@map("action_editors")
}

enum BotExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum GlobalRole {
  ADMIN
  EDITOR_IN_CHIEF
  MANAGING_EDITOR
  USER
  BOT
}

enum ParticipantRole {
  OBSERVER
  PARTICIPANT
  MODERATOR
}

enum ManuscriptStatus {
  SUBMITTED
  UNDER_REVIEW
  REVISION_REQUESTED
  REVISED
  ACCEPTED
  REJECTED
  PUBLISHED
  RETRACTED
}

enum ReviewStatus {
  PENDING
  ACCEPTED
  DECLINED
  IN_PROGRESS
  COMPLETED
}

enum MessagePrivacy {
  PUBLIC
  AUTHOR_VISIBLE
  REVIEWER_ONLY
  EDITOR_ONLY
  ADMIN_ONLY
}

enum ConversationType {
  EDITORIAL
  REVIEW
  SEMI_PUBLIC
  PUBLIC
  AUTHOR_ONLY
}

enum PrivacyLevel {
  PRIVATE
  SEMI_PUBLIC
  PUBLIC
}

enum ManuscriptFileType {
  SOURCE          // Primary source document
  ASSET           // Supporting files (images, data, etc.)
  RENDERED        // Bot-generated rendered outputs
  SUPPLEMENTARY   // Supplementary materials
}

enum StorageType {
  LOCAL
  S3
  GCS
  AZURE
}
