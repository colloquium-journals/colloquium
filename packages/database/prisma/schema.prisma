// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  name        String?
  orcidId     String?  @unique
  bio         String?
  affiliation String?
  website     String?
  role        UserRole @default(AUTHOR)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relationships
  authoredMessages         Message[]
  authoredManuscripts      ManuscriptAuthor[]
  reviewAssignments        ReviewAssignment[]
  magicLinks               MagicLink[]
  conversationParticipants ConversationParticipant[]
  actionEditorRole         ActionEditor[]            @relation("ActionEditorRole")
  assignedActionEditors    ActionEditor[]            @relation("ActionEditorAssigner")

  @@map("users")
}

model MagicLink {
  id          String    @id @default(cuid())
  email       String
  token       String    @unique
  expiresAt   DateTime
  usedAt      DateTime?
  redirectUrl String?
  createdAt   DateTime  @default(now())

  // Relationships
  user   User?   @relation(fields: [userId], references: [id])
  userId String?

  @@map("magic_links")
}

model JournalSettings {
  id          String   @id @default("singleton")
  name        String
  description String?
  logoUrl     String?
  settings    Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("journal_settings")
}

model Manuscript {
  id          String           @id @default(cuid())
  title       String
  abstract    String?
  content     String? // Markdown content
  status      ManuscriptStatus @default(SUBMITTED)
  submittedAt DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  publishedAt DateTime?        // When manuscript was published
  
  // Simple fields for API compatibility
  authors     String[]         // Simple array of author names
  keywords    String[]         @default([])
  fileUrl     String?          // URL to the manuscript file
  metadata    Json?            // Additional metadata

  // Relationships
  authorRelations ManuscriptAuthor[] @relation("authorRelations")
  conversations   Conversation[]
  files           ManuscriptFile[]
  reviews         ReviewAssignment[]
  actionEditor    ActionEditor?

  @@map("manuscripts")
}

model ManuscriptAuthor {
  id              String  @id @default(cuid())
  manuscriptId    String
  userId          String
  order           Int     @default(0)
  isCorresponding Boolean @default(false)

  // Relationships
  manuscript Manuscript @relation("authorRelations", fields: [manuscriptId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id])

  @@unique([manuscriptId, userId])
  @@map("manuscript_authors")
}

model ManuscriptFile {
  id           String   @id @default(cuid())
  manuscriptId String
  filename     String
  originalName String
  mimetype     String
  size         Int
  path         String
  uploadedAt   DateTime @default(now())

  // Relationships
  manuscript Manuscript @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)

  @@map("manuscript_files")
}

model Conversation {
  id           String           @id @default(cuid())
  title        String
  type         ConversationType // EDITORIAL, REVIEW, PUBLIC, etc.
  privacy      PrivacyLevel // PRIVATE, SEMI_PUBLIC, PUBLIC
  manuscriptId String
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  // Relationships
  manuscript   Manuscript                @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  messages     Message[]
  participants ConversationParticipant[]

  @@map("conversations")
}

model ConversationParticipant {
  id             String          @id @default(cuid())
  conversationId String
  userId         String
  role           ParticipantRole @default(PARTICIPANT)
  joinedAt       DateTime        @default(now())

  // Relationships
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id])

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model Message {
  id             String         @id @default(cuid())
  content        String
  conversationId String
  authorId       String
  parentId       String? // For threading
  privacy        MessagePrivacy @default(AUTHOR_VISIBLE)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  isBot          Boolean        @default(false)
  metadata       Json? // Bot-specific data, attachments, etc.

  // Relationships
  conversation  Conversation   @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  author        User           @relation(fields: [authorId], references: [id])
  parent        Message?       @relation("MessageThread", fields: [parentId], references: [id])
  replies       Message[]      @relation("MessageThread")
  botExecutions BotExecution[]

  @@map("messages")
}

model ReviewAssignment {
  id           String       @id @default(cuid())
  manuscriptId String
  reviewerId   String
  status       ReviewStatus @default(PENDING)
  assignedAt   DateTime     @default(now())
  dueDate      DateTime?
  completedAt  DateTime?

  // Relationships
  manuscript Manuscript @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  reviewer   User       @relation(fields: [reviewerId], references: [id])

  @@unique([manuscriptId, reviewerId])
  @@map("review_assignments")
}

model BotDefinition {
  id                String            @id
  name              String
  description       String
  version           String
  author            String
  isPublic          Boolean           @default(false)
  configSchema      Json?             // JSON Schema for bot configuration
  permissions       BotPermission[]   // Required permissions
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @default(now()) @updatedAt

  // Relationships
  install   BotInstall?
  actions   BotAction[]
  executions BotExecution[]

  @@map("bot_definitions")
}

model BotInstall {
  id          String   @id @default(cuid())
  botId       String   @unique
  config      Json     @default("{}")
  isEnabled   Boolean  @default(true)
  installedAt DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  // Relationships
  bot BotDefinition @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@map("bot_installs")
}

model BotPermission {
  id          String @id @default(cuid())
  botId       String
  permission  String // e.g., "manuscript.assign_reviewer", "manuscript.make_decision"
  description String // Human-readable description of what this permission allows

  // Relationships
  bot BotDefinition @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@unique([botId, permission])
  @@map("bot_permissions")
}

model BotAction {
  id          String   @id @default(cuid())
  botId       String
  name        String   // e.g., "assign_reviewer", "make_decision"
  description String
  inputSchema Json     // JSON Schema for action inputs
  createdAt   DateTime @default(now())

  // Relationships
  bot        BotDefinition  @relation(fields: [botId], references: [id], onDelete: Cascade)
  executions BotExecution[]

  @@unique([botId, name])
  @@map("bot_actions")
}

model BotExecution {
  id           String            @id @default(cuid())
  botId        String
  actionId     String?
  messageId    String?           // Message that triggered this execution
  status       BotExecutionStatus @default(PENDING)
  input        Json?             // Input parameters
  output       Json?             // Execution result
  error        String?           // Error message if failed
  executedAt   DateTime          @default(now())
  completedAt  DateTime?

  // Relationships
  bot     BotDefinition @relation(fields: [botId], references: [id], onDelete: Cascade)
  action  BotAction?    @relation(fields: [actionId], references: [id], onDelete: SetNull)
  message Message?      @relation(fields: [messageId], references: [id], onDelete: SetNull)

  @@map("bot_executions")
}

model ActionEditor {
  id           String   @id @default(cuid())
  manuscriptId String
  editorId     String
  assignedAt   DateTime @default(now())
  assignedBy   String?  // User who made the assignment

  // Relationships
  manuscript Manuscript @relation(fields: [manuscriptId], references: [id], onDelete: Cascade)
  editor     User       @relation("ActionEditorRole", fields: [editorId], references: [id])
  assignedByUser User?  @relation("ActionEditorAssigner", fields: [assignedBy], references: [id])

  @@unique([manuscriptId]) // Only one action editor per manuscript
  @@map("action_editors")
}

enum BotExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum UserRole {
  AUTHOR
  REVIEWER
  EDITOR
  ADMIN
}

enum ConversationType {
  EDITORIAL // Editors only
  REVIEW // Editors + assigned reviewers
  SEMI_PUBLIC // + Authors
  PUBLIC // + Community
  AUTHOR_ONLY // Authors discussing among themselves
}

enum PrivacyLevel {
  PRIVATE // Specific participants only
  SEMI_PUBLIC // Journal members can see
  PUBLIC // Anyone can see
}

enum ParticipantRole {
  OBSERVER
  PARTICIPANT
  MODERATOR
}

enum ManuscriptStatus {
  SUBMITTED
  UNDER_REVIEW
  REVISION_REQUESTED
  REVISED
  ACCEPTED
  REJECTED
  PUBLISHED
}

enum ReviewStatus {
  PENDING
  ACCEPTED
  DECLINED
  IN_PROGRESS
  COMPLETED
}

enum MessagePrivacy {
  PUBLIC          // Anyone can see (for fully open journals)
  AUTHOR_VISIBLE  // Authors, reviewers, editors, and admins can see
  REVIEWER_ONLY   // Only reviewers, editors, and admins can see  
  EDITOR_ONLY     // Only editors and admins can see
  ADMIN_ONLY      // Only admins can see
}
